<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>@Test - Современное тестирование Swift Testing</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../welcome.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="chapter-item expanded "><a href="../basic_macro.html"><strong aria-hidden="true">2.</strong> Макросы сравнения</a></li><li class="chapter-item expanded "><a href="../Macros/intro.html"><strong aria-hidden="true">3.</strong> Детальное знакомство с макросами тестирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Macros/macro_test.html" class="active"><strong aria-hidden="true">3.1.</strong> @Test</a></li><li class="chapter-item expanded "><a href="../Macros/macro_suite.html"><strong aria-hidden="true">3.2.</strong> @Suite</a></li><li class="chapter-item expanded "><a href="../Macros/macro_tag.html"><strong aria-hidden="true">3.3.</strong> @Tag</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol_Trait.html"><strong aria-hidden="true">4.</strong> Кортежи</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Comment</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> ConditionTrait</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> HiddenTrait</div></li><li class="chapter-item expanded "><a href="../Traits/TimeLimitTrait.html"><strong aria-hidden="true">4.4.</strong> TimeLimitTrait</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Bug</div></li><li class="chapter-item expanded "><a href="../Traits/IssueTrait.html"><strong aria-hidden="true">4.6.</strong> Issue</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> ParallelizationTrait</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Tag</div></li></ol></li><li class="chapter-item expanded "><a href="../tags.html"><strong aria-hidden="true">5.</strong> Теги везде</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Добавляем собственный кортеж</div></li><li class="chapter-item expanded "><a href="../best_practice_short.html"><strong aria-hidden="true">7.</strong> Best practice</a></li><li class="chapter-item expanded "><a href="../runner.html"><strong aria-hidden="true">8.</strong> Кто управляет тестами</a></li><li class="chapter-item expanded "><a href="../compare_xctest_and_modern_aproach.html"><strong aria-hidden="true">9.</strong> Сравнение с XCTest</a></li><li class="chapter-item expanded "><a href="../xcode_meta.html"><strong aria-hidden="true">10.</strong> Мета информация и обозначения</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Современное тестирование Swift Testing</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="test"><a class="header" href="#test">@Test(…)</a></h1>
<p>Глава про макрос @Test разделена на 4 сценария:</p>
<ul>
<li><a href="#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5-%D0%B8%D0%BB%D0%B8-runtime-condition">Условие</a></li>
<li><a href="#%D0%9E%D0%B1%D1%89%D0%B8%D0%B5-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8-%D0%B8%D0%BB%D0%B8-%D1%82%D1%8D%D0%B3%D0%B8">Общие характеристики или теги</a></li>
<li><a href="#%D0%90%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B">Запуск с различными аргументами</a></li>
<li><a href="#%D0%A2%D0%BE%D0%BD%D0%BA%D0%BE%D1%81%D1%82%D0%B8">Тонкости успользования</a></li>
</ul>
<p>Здесь ты столкнешься с распространенными проблемами в тестировании и узнаешь как их решить.
Помимо этого, я расскажу о тонкостях работы макроса.</p>
<h3 id="Условие-или-runtime-condition"><a class="header" href="#Условие-или-runtime-condition">Условие или runtime condition</a></h3>
<p>Во-первых, тесты с условием.
Некоторые тесты должны выполняться только при определённых обстоятельствах — например, на конкретных устройствах или в определённом окружении (environments).</p>
<p>Для этого, ты можешь применить кортеж условия (<code>ConditionTrait</code>) <code>.enabled(if: ...)</code>:</p>
<pre><code class="language-swift">@Test(.enabled(if: Backport.isRemoteVersion))
func backportVersion() async {
	// ...
}
</code></pre>
<p>Ты передаешь <em>некоторое</em> условие, которое будет оцениваться перед запуском теста и если условие ложно, тест помечается как пропущенный и не выполняется.</p>
<blockquote>
<p>→ Test 'backportVersion()' skipped</p>
</blockquote>
<p>В других случаях необходимо полностью отключить выполнение теста (чтобы тест никогда не выполнялся). Для этого используй кортеж <code>.disabled(...)</code>:</p>
<pre><code class="language-swift">@Test(.disabled("Известный баг, отключаем до фикса #PR-3781"))
func fetchFeatureFlag() async {
  // ...
}
</code></pre>
<blockquote>
<p>→ Test 'fetchFeatureFlag()' skipped: Известный баг, отключаем до фикса #PR-3781</p>
</blockquote>
<p>Использование кортежа <code>.disabled(...)</code> является предпочтительнее комментирования тела функции, поскольку в закомментированном состоянии — тело функции компилируется:</p>
<!-- TODO: Добавить этот кейс в лучшие практики!!! -->
<pre><code class="language-swift">// Избегайте такого способа отключения теста
@Test("Закомментирую на время фикса #PR-3781")
func fetchAnotherFlag() {
// try await Task(priority: .background) {
//	...
// }
}
</code></pre>
<p>Тебе может показаться, что одного комментария недостаточно и по-хорошему нужно указать <strong>причину</strong> отключения: баг, ожидание PR (пулл реквеста) или иное условие. Что ж, в дополнение к комментарию ты можешь использовать кортеж <code>.bug(...)</code>, чтобы явно указать на проблему:</p>
<pre><code class="language-swift">@Test(
	"Проверка валидности поля именя",
	.disabled("Бекендер исправляет модель"),
	.bug("https://github.com/issue/7329", "Сломанная валидация имени и модель #7329")
)
func validateNameProperty() async throws {
	// ...
}
</code></pre>
<p>Данный баг будет отображаться в отчете и вы сможете перейти по ссылке, которая ассоциируется с ним:</p>
<p><img src="../assets/validateNameProperty_link.png" alt="Отчет в Xcode 16" /></p>
<p>Когда необходимо запустить тест только на конкретной версии ОС (операционной системы), можешь использовать <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Checking-API-Availability">атрибут @available(...)</a>, чтобы указать на какой версии доступен тест.
Атрибут <code>@available(...)</code> позволяет понимать, что у теста есть условие, связанное с версией операционной системы и точнее отражать это в результатах.</p>
<pre><code class="language-swift">@Test
@available(macOS 15, *)
func usesNewAPIs() {
  // ...
}
</code></pre>
<p>Избегайте использования проверки доступности с помощью макросов <code>#available</code> и <code>#unavailable</code>:</p>
<pre><code class="language-swift">// ❌ Избегайте использования проверки доступности в рантайме с помощью #available и #unavailable
@Test
func hasRuntimeVersionCheck() {
  guard #available(macOS 15, *) else { return }
  // ...
}

&lt;!-- TODO: Пример с unavailable --&gt;

// ✅ Используйте атрибут @available для функции или метода
@Test
@available(macOS 15, *)
func usesNewAPIs() {
  // ...
}
</code></pre>
<!-- Проверить для типа данных: @available struct NewAPI {...} -->
<p><img src="../assets/available.png" alt="Available attribute" /></p>
<blockquote>
<p>Атрибут @available(...) используется для обозначения доступности типа данных или функции, а макрос #available используется когда необходимо выполнить часть кода только в определенной версии ОС.</p>
</blockquote>
<h3 id="Общие-характеристики-или-теги"><a class="header" href="#Общие-характеристики-или-теги">Общие характеристики или теги</a></h3>
<p>Давай обсудим, как ты можешь объединять тесты, которые имеют общие свойства, даже если они находятся в разных типах данных или файлах.
Swift Testing поддерживает создание пользовательских тэгов для тестов.</p>
<!-- TODO: Дать определение что такое теги и в контексте тестирования -->
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Тег (или тэг) — это ключевое слово для обозначения общих свойств в тестах.</p>
</div>
<p>В моём проект я уже использовал теги. Найти их можно в навигационном меню Xcode, а именно в Test Navigator снизу.</p>
<!-- TODO: скриншот тегов -->
<p>Чтобы увидеть тесты, к которым применены теги, ты можешь переключиться в новый режим группировки — по тегам.</p>
<!-- TODO: скрин: группировка по тегам -->
<p>Давайте применим тег к одному из тестов, которые мы писали ранее. Для этого мы добавим кортеж <code>.tags(...)</code> в атрибут @Test:</p>
<pre><code class="language-swift">// пример кода 
</code></pre>
<p>Этот тест проверяет логику форматирования данных. В этом проекте уже есть другой тест, связанный с форматированием,
поэтому давайте добавим тэг <code>formattingData</code> и к этому тесту.</p>
<p>После применения, тэг отобразится в Test Navigator под соответствующим тэгом.
Я написал еще один тест, который также проверяет форматирование данных, и добавлю его сюда.
Поскольку оба теста связаны с форматированием информации о видео, давайте сгруппируем их в поднабор.</p>
<p>Теперь мы можем переместить тег formattingData на уровень @Suite, чтобы тэг применялся ко всем тестам в этом @Suite. Далее можно удалить теги из каждого отдельного метода с атрибутом @Test, так как он (кто они?) наследуются.</p>
<p>Вы можете ассоциировать теги с тестами, которые имеют общие черты. Например, вы можете применить общий тег ко всем тестам, которые проверяют определенную функцию или подсистему. Это позволяет запускать все тесты с конкретным тегом, фильтровать их в Test Report и даже видеть аналитические данные, например, когда несколько тестов с одним и тем же тегом начинают падать.</p>
<p>Теги могут применяться к тестам в разных файлах, типам данных, макросу @Suite и даже использоваться в нескольких проектах.</p>
<p>При использовании Swift Testing предпочтительнее использовать теги вместо имен тестов для их включения или исключения из тестового плана. Чтобы добиться наилучших результатов, всегда выбирайте наиболее подходящий тип свойства для каждой ситуации. Не все сценарии должны использовать теги. Например, если вы хотите выразить условие выполнения во время выполнения, используйте .enabled(if ...), как мы обсуждали ранее.</p>
<!-- TODO Скриншот: Recommended practies -->
<p>В главе про @Test я не буду рассказывать о том как создать собсвенный тэг и в целом об этом кортеже, только совместное использование.
Узнать о макросе @Tag можно здесь.</p>
<h3 id="Аргументы"><a class="header" href="#Аргументы">Аргументы</a></h3>
<!-- The last workflow I’d like to show is my favorite. Repeating tests with different arguments each time. 
Here's an example of why that can be useful.
In this project there are several tests which check the number of continents that various videos mention.
Each of them follows a similar pattern: it creates a fresh videoLibrary, looks up a video by name, and then uses the #expect macro to check how many continents it mentions.

These tests work, but they're very repetitive and the more videos we add a test for, the harder it will be to maintain them due to all the duplicated code. Also, when using this pattern we’re forced to give each test a unique function name, but these names are hard to read and they might get out-of-sync with the name of the video they're testing. Instead, we can write all of these as a single test using a feature called parameterized testing. Let’s transform this first test into a parameterized one. The first step is to add a parameter to its signature.
As soon as we do this, an error appears telling us that we must specify the arguments to pass to this test, so let’s fix that.
For now, let’s include the names of just three videos.
I like to split arguments over multiple lines so they're easier to read, but you can format them however you like. The last step is to replace the name of the video being looked up with the passed-in argument.
Since this test now covers multiple videos, let’s generalize its name.
The full name of this test now includes its parameter label.
But we can still give it a display name or other traits if we want, by passing them before the arguments. -->
<p>Последний рабочий процесс, который я хочу показать, — мой любимый. Повторение тестов с разными аргументами каждый раз.
Вот пример того, почему это может быть полезно.
В этом проекте есть несколько тестов, которые проверяют количество континентов, упомянутых в различных видео.
Каждый из них следует схожей схеме: создается новая библиотека видео, затем выполняется поиск видео по названию, после чего макрос #expect используется для проверки количества континентов, упомянутых в видео.</p>
<p>Эти тесты работают, но они слишком однотипны, и чем больше видео мы добавляем для тестирования, тем сложнее их поддерживать из-за дублирующегося кода. Кроме того, при использовании этого подхода нам приходится давать каждому тесту уникальное имя функции, но эти имена трудно читать, и они могут не совпадать с названием тестируемого видео. Вместо этого мы можем записать все эти тесты как один, используя функцию, называемую параметризованным тестированием. Давайте преобразуем этот первый тест в параметризованный.</p>
<p>Первый шаг — добавить параметр в его сигнатуру.
Как только мы это сделаем, появляется ошибка, сообщающая, что необходимо указать аргументы для передачи в тест. Исправим это.
Для начала включим названия только трех видео.
Мне нравится разбивать аргументы на несколько строк, чтобы их было легче читать, но вы можете форматировать их так, как вам удобно.
Последний шаг — заменить название видео, которое ищется, на переданный аргумент.
Поскольку этот тест теперь охватывает несколько видео, давайте обобщим его название.
Полное название этого теста теперь включает метку параметра.
Однако мы все еще можем задать ему отображаемое имя или другие свойства, если захотим, передав их перед аргументами.</p>
<!-- Now let's run the test and see how it goes.
Great! It succeeded, and the Test Navigator shows each individual video below it as if it were a separate test. This structure makes it really easy to add more arguments and expand test coverage. Let’s add all the remaining videos to this list — and even a couple new ones.
At this point, we can delete the old @Test functions since they're no longer necessary.
Let's run the test one more time and make sure it's still passing.
Hm, it looks like one of the new videos we added near the end is causing a failure now. By clicking the argument, we can see details about it, and the expectation which failed. To investigate this problem, it would help to re-run it with the debugger, but I'd prefer to only re-run the argument that failed to save some time. In Xcode 16 we can now run an individual argument by clicking its run button in the Test Navigator. But before we do this, let’s add a breakpoint to the beginning of the test.
And now let’s re-run it.
The videoName shown in the debugger is "Scotland Coast”, so we know we’re running this test with exactly the argument we're interested in. From here, we could continue debugging further and identify the reason for the failure. Conceptually, a parameterized test is similar to a single test that is repeated multiple times using a for…in loop. Here’s an example: it has an array of videoNames that it loops over to perform the test. However, using a for...in loop like this has some downsides.
Parameterized testing allows you see the details of each individual argument clearly in the results. The arguments can be re-run independently for fine-grained debugging. And they can be executed more efficiently by running each argument in parallel, so you can get results more quickly.
Parameterized tests can be used in even more advanced ways than we saw here, such as by testing all combinations of two sets of inputs.

Whenever you see a test using this pattern, it’s best to transform it into a parameterized test function. Just add a parameter to the function, get rid of the for...in loop, move the arguments up to the @Test attribute, and you’re done! -->
<p>Теперь давайте запустим тест и посмотрим, как он пройдет.
Отлично! Тест успешно завершился, и в Test Navigator для каждого отдельного видео отображается его собственная запись, как если бы это были отдельные тесты. Такая структура упрощает добавление новых аргументов и расширение охвата тестов. Давайте добавим в этот список все оставшиеся видео, а также пару новых.
На этом этапе мы можем удалить старые функции с аннотацией @Test, так как они больше не нужны.
Запустим тест еще раз и убедимся, что он все еще проходит.</p>
<p>Хм, похоже, одно из новых видео, добавленных ближе к концу, вызывает ошибку. Нажав на аргумент, мы можем увидеть подробности и узнать, какое ожидание не было выполнено. Чтобы разобраться в проблеме, можно повторно запустить тест с отладчиком, но я бы предпочел перезапустить только тот аргумент, который вызвал сбой, чтобы сэкономить время. В Xcode 16 теперь можно запустить отдельный аргумент, нажав на его кнопку запуска в Test Navigator. Но прежде чем это сделать, давайте установим точку останова в начале теста.</p>
<p>Теперь перезапустим его.
Имя видео, отображаемое в отладчике — “Scotland Coast”, поэтому мы знаем, что тест выполняется именно с тем аргументом, который нас интересует. Отсюда мы можем продолжить отладку и выяснить причину сбоя.</p>
<p>Концептуально параметризованный тест похож на один тест, который выполняется несколько раз с использованием цикла for…in. Вот пример: в нем есть массив videoNames, который перебирается для выполнения теста. Однако использование цикла for…in имеет свои недостатки.
Параметризованное тестирование позволяет четко видеть детали каждого отдельного аргумента в результатах. Аргументы можно запускать повторно независимо для точной отладки. Кроме того, их можно выполнять более эффективно, запуская каждый аргумент параллельно, что ускоряет получение результатов.</p>
<p>Параметризованные тесты можно использовать даже в более сложных сценариях, например для тестирования всех комбинаций двух наборов входных данных.</p>
<p>Когда вы видите тест, использующий этот шаблон, лучше преобразовать его в параметризованную тестовую функцию. Просто добавьте параметр в функцию, избавьтесь от цикла for…in, переместите аргументы в аннотацию @Test — и готово!</p>
<hr />
<p>Теперь поговорим о том, как Swift Testing и XCTest соотносятся друг с другом. Если вы уже писали тесты на XCTest, то, возможно, задаетесь вопросом, как эта новая система тестирования сравнивается с XCTest и как можно перенести существующие тесты. Swift Testing имеет некоторые сходства с XCTest, но также обладает важными отличиями, которые стоит учитывать. Давайте сравним три основные составляющие: тестовые функции, ожидания и наборы тестов.</p>
<p>В XCTest тестами считаются методы, название которых начинается с «test». В Swift Testing для явного обозначения тестов используется атрибут @Test, что исключает двусмысленность.
Swift Testing поддерживает больше видов функций: вы можете использовать как методы экземпляра, так и статические или глобальные функции. В отличие от XCTest, Swift Testing поддерживает «черты» для указания информации как для каждого теста, так и для всего набора. Кроме того, Swift Testing использует другой подход к параллелизации: тесты выполняются в процессе с использованием Swift Concurrency и поддерживают физические устройства, такие как iPhone и Apple Watch.</p>
<p>Ожидания в этих двух системах сильно различаются. XCTest использует концепцию утверждений (assertions) и множество функций, начинающихся с XCTAssert. Swift Testing подходит к этому иначе: в нем всего два основных макроса — #expect и #require. Вместо множества специализированных функций вы можете передавать обычные выражения и операторы языка в #expect или #require. Например, для проверки равенства можно использовать оператор двойного равенства, а для сравнения значений — оператор «больше». Также легко можно использовать противоположный оператор, чтобы отрицать любое ожидание.</p>
<p>Завершение теста после сбоя реализовано по-разному. В XCTest нужно установить свойство continueAfterFailure в значение false, чтобы тест завершался после первой неудачной проверки. В Swift Testing любое ожидание можно сделать обязательным, заменив #expect на #require, и оно вызовет ошибку при сбое. Это позволяет выбирать, какие ожидания должны завершать тест, и даже менять их поведение по ходу теста.</p>
<p>Что касается типов наборов тестов, XCTest поддерживает только классы, которые должны наследоваться от XCTestCase. В Swift Testing можно использовать структуры, актеры или классы. Причем структуры предпочтительны, так как они используют семантику значений и предотвращают ошибки, вызванные непреднамеренным совместным использованием состояния.
Наборы тестов можно явно обозначить с помощью атрибута @Suite, хотя это необязательно для любого типа, содержащего тестовые функции или вложенные наборы. Атрибут требуется только для указания отображаемого имени или других характеристик.</p>
<p>Для выполнения логики перед каждым тестом в XCTest используются методы setUp, а в Swift Testing — инициализатор типа, который может быть асинхронным или генерировать ошибки. Если нужно выполнить логику после каждого теста, можно использовать деинициализатор. Деинициализаторы могут использоваться только для актеров и классов, что является основной причиной выбора ссылочного типа вместо структуры для набора тестов.</p>
<p>В Swift Testing можно группировать тесты в подгруппы через вложенные типы.
Тесты XCTest и Swift Testing могут сосуществовать в одной цели, поэтому при миграции можно делать это постепенно, без необходимости создавать новую цель. При переносе нескольких методов XCTest с похожей структурой их можно объединить в один параметризованный тест, как мы обсуждали ранее. Для классов XCTest с единственным методом теста можно перенести его в глобальную функцию с атрибутом @Test.</p>
<p>Имя тестов больше не обязательно должно начинаться с «test».
Продолжайте использовать XCTest для тестов, которые используют API автоматизации пользовательского интерфейса, такие как XCUIApplication, или API для тестирования производительности, такие как XCTMetric, так как они не поддерживаются в Swift Testing. Также XCTest необходимо для тестов, которые можно писать только на Objective-C. Однако вы можете использовать Swift Testing для написания тестов на Swift, которые проверяют код, написанный на другом языке.</p>
<p>Избегайте вызова функций утверждений XCTest в тестах Swift Testing и наоборот — макроса #expect в тестах XCTest.
Обязательно ознакомьтесь с разделом «Migrating a test from XCTest» в нашей документации. Там много деталей о переводе утверждений, обработке асинхронных условий ожидания и многом другом.</p>
<p>Мы рассмотрели функции Swift Testing и показали несколько способов их использования. Это только начало для этого нового пакета, и я рад, что он будет продолжать развиваться в сообществе. Swift Testing — это проект с открытым исходным кодом, размещенный на GitHub. Вскоре он перейдет в недавно объявленную организацию swiftlang.</p>
<p>Пакет работает на всех операционных системах Apple, поддерживающих Swift Concurrency, а также на Linux и Windows. Важным улучшением является единая кодовая база для всех этих платформ! Это обеспечивает более согласованное поведение тестов при переключении между платформами и лучшее функциональное соответствие.</p>
<p>Swift Testing интегрирован в основные инструменты и среды разработки Swift, включая Swift Package Manager в командной строке, а также Xcode 16 и VS Code с последними версиями расширения для Swift.</p>
<p>Давайте рассмотрим работу Swift Testing в командной строке. Вот простой пакет, который я создал с использованием шаблона New Package в Xcode 16. Мы можем запустить тесты этого пакета из Терминала, введя команду swift test.
Это запускает как тесты XCTest, так и Swift Testing. В консоли отображаются результаты прохождения и сбоев с использованием цветного вывода, а также подробные сообщения об ошибках, аналогичные тем, что показываются в Xcode.</p>
<p>У Swift Testing есть процесс предложений новых функций, и мы обсуждаем его развитие на Swift Forums. Мы приглашаем вас принять участие: предлагать или обсуждать функции, улучшать документацию или сообщать об ошибках. Все вклады приветствуются!</p>
<p>Итак, это Swift Testing. Используйте его мощные функции, такие как ожидания и параметризованное тестирование, чтобы улучшить качество вашего кода; настраивайте тесты с помощью черт и присоединяйтесь к нам на GitHub и форумах, чтобы влиять на будущее этого пакета.</p>
<h3 id="Тонкости"><a class="header" href="#Тонкости">Тонкости</a></h3>
<p>Последний параграф познакомит тебя с особенностями использования макроса <code>@Test</code>, которые доступны при детальном чтении исходного кода, который реализует сам макрос. За это отвечает структура данных <code>TestDeclarationMacro</code>.</p>
<!-- Дать определение, о чем именно тонкости -->
<pre><code class="language-swift">@Test("Как определить, функция для теста изолирована на глобальном акторе ?")
@MainActor
func determineGlobalActor() async {
	await MainActor.run {}
}
</code></pre>
<p>// How do we call a function if we don't know whether it's <code>async</code> or
// <code>throws</code>? Yes, we know if the keywords are on the function, but it could
// be actor-isolated or otherwise declared in a way that requires the use of
// <code>await</code> without us knowing. Abstract away the need to know by invoking
// the function along with an expression that always needs <code>try</code> and one
// that always needs <code>await</code>, then discard the results of those expressions.
//
// We may also need to call init() (although only for instance methods.)
// Since we can't see the actual init() declaration (and it may be
// synthesized), we can't know if it's noasync, so we assume it's not.
//
// If the function is noasync, we will need to call it from a synchronous
// context. Although <code>async</code> is out of the picture, we still don't know if
// <code>try</code> is needed, so we do the same tuple dance within the closure.
// Calling the closure requires <code>try</code>, hence why we have two <code>try</code> keywords.
//
// If the function is noasync <em>and</em> main-actor-isolated, we'll call through
// MainActor.run to invoke it. We do not have a general mechanism for
// detecting isolation to other global actors.</p>
<pre><code class="language-swift">lazy var isMainActorIsolated = !functionDecl.attributes(named: "MainActor", inModuleNamed: "_Concurrency").isEmpty
var forwardCall: (ExprSyntax) -&gt; ExprSyntax = {
  "try await Testing.__requiringTry(Testing.__requiringAwait(\($0)))"
}

let forwardInit = forwardCall

if functionDecl.noasyncAttribute != nil {
  if isMainActorIsolated {
    forwardCall = {
      "try await MainActor.run { try Testing.__requiringTry(\($0)) }"
    }
  } else {
    forwardCall = {
      "try { try Testing.__requiringTry(\($0)) }()"
    }
  }
}
</code></pre>
<h4 id="Нет-необходимости-возвращать-тип-данных"><a class="header" href="#Нет-необходимости-возвращать-тип-данных">Нет необходимости возвращать тип данных</a></h4>
<p>Если ты внимательно читал код, то обратил внимание что ни одна функция не возвращает конкретный тип данных.
Указание возвращаемого типа данных не является ошибкой, проверка с помощью макросов выполняется, но в этом случае ты получишь предупреждение:</p>
<pre><code class="language-swift">@Test
func checkReturnType() -&gt; any Collection {
  let collection = Array(1...10)
  #expect(collection.contains(10))

  return collection
}
</code></pre>
<blockquote>
<p>⚠️ The result of this function will be discarded during testing</p>
</blockquote>
<p>Возможно в будущем, инженеры Apple добавят такую возможность, но на данный момент они не нашли подходящего сценария, при котором необходимо возвращать тип данных.
Такая проверка возможна с помощью проверки сигнатуры возвращаемого типа:</p>
<pre><code class="language-swift">if let returnType = function.signature.returnClause?.type, !returnType.isVoid {
    diagnostics.append(.returnTypeNotSupported(returnType, on: function, whenUsing: testAttribute))
}
</code></pre>
<h4 id="Неподдерживаемые-ключевые-слова"><a class="header" href="#Неподдерживаемые-ключевые-слова">Неподдерживаемые ключевые слова</a></h4>
<p>На момент выхода книги, в структуре данных <a href="https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/TestDeclarationMacro.swift#L84">TestDeclarationMacro</a>, которая реализует макрос <code>@Test</code>, существуют неподдерживаемые ключевые слова:</p>
<pre><code class="language-swift">struct TestDeclarationMacro: PeerMacro, Sendable {
    // ...
    // We don't support inout, isolated, or _const parameters on test functions.
    for parameter in parameterList {
        let invalidSpecifierKeywords: [TokenKind] = [.keyword(.inout), .keyword(.isolated), .keyword(._const),]
        // ...
    }
}
</code></pre>
<p>Это легко проверить, создав тест с одним из этих ключевых слов:</p>
<pre><code class="language-swift">@Test("Проверка не поддерживаемых слов")
func parameterCanBeSupported(value: isolated (any Actor)? = #isolation) {}
</code></pre>
<blockquote>
<p>❌ Attribute <code>Test</code> cannot be applied to a function with a parameter marked <code>isolated</code></p>
</blockquote>
<h4 id="test-только-для-func"><a class="header" href="#test-только-для-func">Test только для func</a></h4>
<p>Возможно тебе захочется применить атрибут для теста замыкания, но ничего не выйдет. При сборке таргета с тестами, кнопки запуска не появится.
Или иными словам, ты можешь применить атрибут только для функций или методов:</p>
<pre><code class="language-swift">// The @Test attribute is only supported on function declarations.
guard let function = declaration.as(FunctionDeclSyntax.self) else {
    diagnostics.append(.attributeNotSupported(testAttribute, on: declaration))
    return false
}
</code></pre>
<h4 id="1-атрибут-для-1-функции"><a class="header" href="#1-атрибут-для-1-функции">1 атрибут для 1 функции</a></h4>
<p>Да, для кого-то это покажется слишком очевидным, но применить атрибут <code>@Test</code> можно только 1 раз:</p>
<pre><code class="language-swift">// Only one @Test attribute is supported.
let suiteAttributes = function.attributes(named: "Test")

if suiteAttributes.count &gt; 1 {
    diagnostics.append(.multipleAttributesNotSupported(suiteAttributes, on: declaration))
}
</code></pre>
<h4 id="Не-приминим-для-generics"><a class="header" href="#Не-приминим-для-generics">Не приминим для Generics</a></h4>
<pre><code class="language-swift">
/// Create a diagnostic message stating that the `@Test` or `@Suite` attribute
/// cannot be applied to a generic declaration.

static func genericDeclarationNotSupported(_ decl: some SyntaxProtocol, whenUsing attribute: AttributeSyntax, becauseOf genericClause: some SyntaxProtocol, on genericDecl: some SyntaxProtocol) -&gt; Self {
  if Syntax(decl) != Syntax(genericDecl), genericDecl.isProtocol((any DeclGroupSyntax).self) {
      return .containingNodeUnsupported(genericDecl, genericBecauseOf: Syntax(genericClause), whenUsing: attribute, on: decl)
  } else {
      // Avoid using a syntax node from a lexical context (it won't have source location information.)
      let syntax = (genericClause.root != decl.root) ? Syntax(decl) : Syntax(genericClause)
      return Self(
      syntax: syntax,
      message: "Attribute \(_macroName(attribute)) cannot be applied to a generic \(_kindString(for: decl))",
      severity: .error
      )
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Macros/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Macros/macro_suite.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Macros/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Macros/macro_suite.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
