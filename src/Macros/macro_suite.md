# @Suite

Что приходит на ум при работе с большим количеством функций?
Правильно, возможность упорядочить их с помощью чего-либо, а ещё лучше объединить их в один тип данных.
Макрос @Suite идеально подходит не только для объединения в один тип данных, а так же для использования трейтов.

Вообще, такая группировка возможна в 2ух сценариях:

- С помощью пользовательских типов данных
- Применяя атрибут @Suite для пользовательских типов данных

К таким типам данных относят: `struct`, `class`, `actor` и `enum`.

```swift
@Suite
struct SingleProfile {...}

@Suite
class SharedService {...}

@Suite
actor DatabaseProvider {...}

@Suite
enum SwaggerAPI {...}
```

> [!TIP]
> `@Suite` не является обязательным атрибутом для применения, но позволяет использовать трейты, подобные в макросе `@Test`, для расширения функционала.

Атрибут @Suite не является обязательным для распознавания тестовых функций, содержащихся в типе, но его использование позволяет настраивать отображение тестового набора в IDE и в командной строке. Если к тестовому набору применён атрибут, такой как tags(_:) или disabled(_:sourceLocation:), он автоматически наследуется всеми тестами, содержащимися в наборе.

Тестовые наборы могут содержать не только тестовые функции, но и другие члены типа Swift. Также они могут содержать вложенные тестовые наборы. Чтобы добавить вложенный тестовый набор, нужно объявить дополнительный тип внутри основного тестового набора.

По умолчанию тесты в рамках одного набора выполняются параллельно. Подробнее о параллелизации можно узнать в разделе Запуск тестов последовательно или параллельно.

## Настройка имени данным

Чтобы задать имя тестового набора, передайте строковый литерал в качестве аргумента для атрибута @Suite:

```swift
@Suite("Food truck tests")
struct FoodTruckTests {
    @Test func foodTruckExists() {
        // Тестовая логика
    }
}
```

Для дальнейшей настройки внешнего вида и поведения тестовой функции можно использовать атрибуты (или трейты?), такие как `.tags(_:)`.

## Тестовые функции в типах Suite

Если тестовая функция объявлена как метод экземпляра (без использования ключевых слов static или class), библиотека тестирования вызывает эту функцию, создавая экземпляр типа, а затем вызывает метод на этом экземпляре. Например:

```swift
@Suite 
struct FoodTruckTests {
    @Test 
    func foodTruckExists() {
        // Логика теста
    }
}
```

Эквивалентно следующему:

```swift
@Suite 
struct FoodTruckTests {
    func foodTruckExists() {
        // Логика теста
    }

    @Test 
    static func staticFoodTruckExists() {
        let instance = FoodTruckTests()
        instance.foodTruckExists()
    }
}
```

## Ограничения для типов Suite

При использовании типа как тестового набора накладываются дополнительные ограничения:

- Необходимость наличия инициализатора

Если тип содержит тестовые функции, объявленные как методы экземпляра, он должен быть инициализирован с помощью инициализатора без аргументов. Инициализатор может быть:

- явным или неявным;
- синхронным или асинхронным;
- бросающим исключения (`init() throws`) или обычным;
- любого уровня доступа (`private`, `internal`, `public`).

Пример:

```swift
@Suite
struct FoodTruckTests {
    var batteryLevel = 100

    @Test
    func foodTruckExists() { } // ✅ OK: есть неявный инициализатор.
}

@Suite
struct CashRegisterTests {
    private init(cashOnHand: Decimal = 0.0) async throws { }

    @Test
    func calculateSalesTax() { } // ✅ OK: доступен явный инициализатор.
}

struct MenuTests {
    var foods: [Food]
    var prices: [Food: Decimal]

    @Test
    static func specialOfTheDay() { } // ✅ OK: функция статическая.
    
    @Test
    func orderAllFoods() { } // ❌ Ошибка: типу требуется инициализатор.
}
```

Компилятор выдаст ошибку, если тип набора не удовлетворяет этому требованию.

## Постоянная доступность типов Suite

Атрибут @available можно применять к тестовой функции, чтобы ограничить её доступность во время выполнения. Однако тип тестового набора и любые содержащие его типы не могут быть аннотированы этим атрибутом:

@Suite struct FoodTruckTests { } // ✅ OK: тип всегда доступен.

@available(macOS 11.0, *) // ❌ Ошибка: тип набора должен быть всегда доступен.
@Suite struct CashRegisterTests { }

@available(macOS 11.0, *) struct MenuItemTests { // ❌ Ошибка: содержащий тип должен быть доступен.
    @Suite struct BurgerTests { }
}

Компилятор выдаст ошибку, если тип набора нарушает это правило.
