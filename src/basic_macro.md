# Базовые макросы сравнения

В этой главе мы изучим базовые макросы сравнения. Вы можете использовать проект из этой книги или создать пустой проект, добавив в таргет новую систему тестирования.
Рассмотрим функцию, импортировав новый фреймворк `Testing`:

```swift
import Testing

@Test
func calculateTotal() { }
```

Данная функция не отличается от обычной swift функции, за исключением добавленного атрибута `@Test`.

> [!NOTE]
> С помощью атрибута `@Test` сообщаем, что функция подлежит тестированию.

Другие условия, когда функция подлежит тестированию, помимо атрибута `@Test`:

- Может быть глобальной или быть методом в типе
- Может быть асинхронной и помечена `throws`
- Может быть изолирована любым глобальным актором (например, `@MainActor`)

#### Макрос сравнения #expect

На примере калькулятора импортируем внутренний (`internal`) модуль и фреймворк `Testing`:

```swift
// Мое приложение называется ModerApp
@testable
import ModernApp

import Testing

@Test
func calculateTotal() async {
	let calc = BestCalculator(value: [3, 5, 1])
	await #expect(calc.total == 19)
}
```

С помощью макроса `#expect()` мы проверяем сумму трех чисел: 3, 5 и 1 и сравниваем её с числом 19.

Получаем ошибку сравнения, поскольку `9 не равно 19`:

> ❌ Expectation failed: (calc.total → 9) == 19

Одна функция не ограничена одной проверкой, поэтому их может быть несколько:

```swift
@Test
func calculateTotal() async {
	let calc = BestCalculator(value: [3, 5, 1])
	
	await #expect(calc.total == 19) // ❌ Expectation failed: (calc.total → 9) == 19
	await #expect(calc.value.isEmpty) // ❌ Expectation failed: (calc.value → [3, 5, 1]).isEmpty → false
	await #expect(type(of: calc.value) == Array<Int>.self) // ✅ Значения калькулятора являются массивом целых чисел
}
```

> [!NOTE]
> Ключевое слово `await` используется для свойства `total`, поскольку `BestCalculator` является актором.

Макрос `#expect` очень гибкий. Вы можете передать любое выражение, включая асинхронное, оператор сравнения `==`, вызвать свойство `.isEmpty` и т.д.
При неудачном выполнени, результат сравнения будет показан наглядно и нет необходимости использовать сторонние инструменты, чтобы увидеть содержимое массива или его сумму.


Перед тем, как перейти к следующему макросу сравнения, упомяну возможности кастомизации макроса `@Test`.
В чем смысл нового инструмента, если он не решает никаких проблем? Правильно, поэтому ты можешь задать имя для теста:

```swift
@Test("Проверка пустой суммы калькулятора")
func calcWithEmptyValues() async {
	let calc = BestCalculator(value: [])
	await #expect(calc.total == .zero)
}
```

Имя теста можно найти во вкладке навигации тестов (⌘ + 6). Тесты, без заданных имен, обозначаются названием функции.
<!-- TODO: Скрин сюда -->

Помимо кастомизации имени, макрос `@Test` поддерживает другие фичи.
О других возможностях макроса `@Test` [прочитай здесь][link_to_test_macro].

#### Макрос сравнения #require


<!--
Написать другой пример и показать, почему второе сравнения не имеет смысла, если значение равно nil

1. Пример с enum
2. Пример с Optional
-->

Макрос обязательного сравнения (required expectations) схож с предыдущим за исключением 2 деталей.
`#require` использует ключевое слово `try` и если выражение выкинуло ошибку, то осуществляется ранний выход и тест завершается.
Помимо этого, `try #require` идеально подходит для получения опционального значения.


> [!TIP]
> `try #require` идеально подходил для получения опционального значения и раннего выхода функции.


### Группировка тестов





И в самом конце написать: более подробно про макрос expect в главе, про макрос require в другой главе.
А как делать группировку с помощью макрос `@Suite`, можно узнать в главе.

<!--
### Макрос #expect(1 == 2) подробно
Возможно вынести в отдельный файл и сделать более детальный разбор ?

Здесь пример с throws и прочее.

В простом варианте принимает 3 параметра:

1. Некоторое условие `condition: Bool`
2. Кортеж `Testing.Comment`, являющийся одиночным комментарием
3. Кортеж `Testing.SourceLocation`, указывающий нахождение макроса в коде

```swift
@freestanding(expression)
public macro expect(
    _ condition: Bool,
    _ comment: @autoclosure () -> Testing.Comment? = nil, sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) = #externalMacro(module: "TestingMacros", type: "ExpectMacro")
```

### Макрос #require(value = nil)
!todo Идеально подходит для опциональных значений и раннего выхода.


#### На примере

Сделать запрос в сеть на примере API.
-->
