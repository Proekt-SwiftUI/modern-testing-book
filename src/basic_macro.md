# Базовые макросы сравнения

В этой главе мы изучим базовые макросы сравнения. Вы можете использовать проект из этой книги или создать пустой проект, добавив в таргет новую систему тестирования.
<!-- Скрин добавления новой системы тестирования -->
Рассмотрим функцию, импортировав новый фреймворк `Testing`:

```swift
import Testing

@Test
func calculateTotal() { }
```

Данная функция не отличается от обычной swift функции, за исключением добавленного атрибута `@Test`.

> [!NOTE]
> С помощью атрибута `@Test` сообщаем, что функция подлежит тестированию.

Другие условия, когда функция подлежит тестированию, помимо атрибута `@Test`:

- Может быть глобальной или быть методом в типе
- Может быть асинхронной и помечена `throws`
- Может быть изолирована любым глобальным актором (например, `@MainActor`)

#### Макрос сравнения #expect

На примере калькулятора импортируем внутренний (`internal`) модуль и фреймворк `Testing`:

```swift
// Мое приложение называется ModerApp
@testable
import ModernApp

import Testing

@Test
func calculateTotal() async {
	let calc = BestCalculator(value: [3, 5, 1])
	await #expect(calc.total == 19)
}
```

С помощью макроса `#expect()` мы проверяем сумму трех чисел: 3, 5 и 1 и сравниваем её с числом 19.

Получаем ошибку сравнения, поскольку `9 не равно 19`:

> ❌ Expectation failed: (calc.total → 9) == 19

Одна функция не ограничена одной проверкой, поэтому их может быть несколько:

```swift
@Test
func calculateTotal() async {
	let calc = BestCalculator(value: [3, 5, 1])
	
	await #expect(calc.total == 19) // ❌ Expectation failed: (calc.total → 9) == 19
	await #expect(calc.value.isEmpty) // ❌ Expectation failed: (calc.value → [3, 5, 1]).isEmpty → false
	await #expect(type(of: calc.value) == Array<Int>.self) // ✅ Значения калькулятора являются массивом целых чисел
}
```

> [!NOTE]
> Ключевое слово `await` используется для свойства `total`, поскольку `BestCalculator` является актором.

Макрос `#expect` очень гибкий. Вы можете передать любое выражение, включая асинхронное, оператор сравнения `==`, вызвать свойство `.isEmpty` и т.д.
При неудачном выполнени, результат сравнения будет показан наглядно и нет необходимости использовать сторонние инструменты, чтобы увидеть содержимое массива или его сумму.


Перед тем, как перейти к следующему макросу сравнения, упомяну возможности кастомизации макроса `@Test`.
В чем смысл нового инструмента, если он не решает никаких проблем? Правильно, поэтому ты можешь задать имя для теста:

```swift
@Test("Проверка пустой суммы калькулятора")
func calcWithEmptyValues() async {
	let calc = BestCalculator(value: [])
	await #expect(calc.total == .zero)
}
```

Имя теста можно найти во вкладке навигации тестов (⌘ + 6). Тесты, без заданных имен, обозначаются названием функции.
<!-- TODO: Скрин сюда -->

Помимо кастомизации имени, макрос `@Test` поддерживает другие фичи.
О других возможностях макроса `@Test` [прочитай здесь][link_to_test_macro].

#### Макрос сравнения #require

Иногда необходимо закончить выполнение теста заранее и вернуть ошибку. Для этого можем использовать макрос `#require`:

```swift
@Test("Правильная проверка опционального города")
func userHaveCity() async throws {
	let profileData = ProfileData()
	await profileData.getProfile(id: 1)

	let city: String = try #require(profileData.user?.city) // ❌ Expectation failed
	
	#expect(city == "Ísafjörður")
	await profileData.updateUserProfile()
}
```

> ❌ Expectation failed: (profileData.user → UserProfile(id: 1, firstName: "Nick", lastName: "Rossik", email: nil, city: nil)).city → nil → nil

Города данного пользователя равен `nil`, поэтому тест завершилась неудачей, сравнение города ниже и метод `await profileData.updateUserProfile()` не был выполнен.

<!--
Написать другой пример и показать, почему второе сравнения не имеет смысла, если значение равно nil
-->

Макрос обязательного сравнения (required expectations) схож с предыдущим за исключением 2 деталей.
`#require` использует ключевое слово `try` и если выражение выкинуло ошибку, то осуществляется ранний выход и тест завершается.
Помимо этого, `try #require` идеально подходит для получения опционального значения.


> [!TIP]
> `try #require` идеально подходил для получения опционального значения и раннего выхода функции.

Попробуем получить профиль пользователя. Заранее скажу, что при передаче в метод нулевого айди `getProfile(id: )`, пользователь не будет найден,
и поэтому вернется `nil`.
Воспользуемся оператором `guard let` и попытается развернуть опциональное значение:

```swift
@Test("❌ Неправильная проверка опционального города")
func userProfileHaveCity() async {
	let profileData = ProfileData()
	await profileData.getProfile(id: .zero)

	// Юзера с айди .zero не существует.
	guard let user = profileData.user else {
		return
	}

	#expect(user.city != nil)
	#expect(user.city == "Moscow")
}
```

Значение `profileData.user` равно `nil` и остальная часть теста зависит от этого свойства.
В результате тест должен был завершиться ошибкой, но этого не происходит. Логика в тесте не верная!

> [!IMPORTANT]
> Старайтесь использовать `#require` вместо `guard` или `guard let`.


### Организация тестов

Тесты, которые ты ранее встречал, были глобальными, т.е. не принадлежали к какому-либо типу данных.
Для организации тестов можем использовать любой тип данных существующий в Swift, например структуру:

```swift
 struct UserProfileTest {
	 @Test("❌ Неправильная проверка опционального города")
	 func userProfileHaveCity() async {}

	 @Test("Правильная проверка опционального города")
	 func userHaveCity() async throws {}

	 // … другие тесты
 }
```

Навигация тестов содержит название типа данных. Про @Suite упомянуть…


И в самом конце написать: более подробно про макрос expect в главе, про макрос require в другой главе.
А как делать группировку с помощью макрос `@Suite`, можно узнать в главе.
